<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-cs61b-lab01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/07/cs61b-lab01/" class="article-date">
  <time class="dt-published" datetime="2024-07-07T03:15:46.000Z" itemprop="datePublished">2024-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/07/cs61b-lab01/">cs61b-lab01</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Lab01-Setup-git"><a href="#Lab01-Setup-git" class="headerlink" title="Lab01:Setup - git"></a>Lab01:Setup - git</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h3><p>Git 是一种分布式版本控制系统，而不是集中式版本控制系统。这意味着每个开发人员的计算机 存储整个项目的整个历史记录（包括所有旧版本）！这与Dropbox等工具不同，在Dropbox中，旧版本存储在一个 其他人拥有的远程服务器。我们把整个历史称为一个整体 项目 A “存储库”。存储库存储在本地的事实导致 我们能够在自己的计算机上本地使用 Git，即使没有互联网连接。</p>
<h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>现在我们有一些文件(四个食谱，两个是豆腐的，两个是 seitan 的)。要设置我们的 <em><strong>Git 仓库</strong></em> 以便存储这些文件(食谱)的<em><strong>历史</strong></em>，我们需要使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /users/sandra/recipes</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>这会告诉 Git 版本控制系统，我们希望跟踪当前目录（在本例中为 recipes 目录）的历史。然而，<strong>此时，仓库中没有任何内容。这就像我们购买了一个保险箱</strong>，但还没有放入任何东西。<code>git init /users/sandra/recipes</code></p>
<p>为了将所有内容存储到仓库中，我们首先需要添加文件。例如，我们可以执行以下操作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add tofu/kung_pao_tofu.txt</span><br></pre></td></tr></table></figure>

<p>现在这里就是 Git 开始显得有些奇怪的地方了。即使在调用这个命令之后，我们<strong>仍然</strong>没有将我们的<strong>食谱存储到仓库中（即保险箱中）</strong>。相反，<strong>我们所做的是将文件添加到要跟踪的文件列表中（即稍后要添加到保险箱中）。这个想法是你可能并不想跟踪文件夹中的每一个文件，所以该命令告诉 Git 应该跟踪哪些文件</strong>。我们可以使用以下命令查看这个命令的效果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>在这种情况下，你会看到以下响应：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">On branch main</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        new file:   tofu/kung_pao_tofu.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        seitan/</span><br><span class="line">        tofu/basil_ginger_tofu.txt</span><br></pre></td></tr></table></figure>

<p><strong>输出中的“Changes to be committed”部分列出了所有当前被跟踪并且其更改已准备好提交（即已准备好放入保险箱）的文件</strong>。我们还看到有一些未跟踪的文件；即文件夹和文件。这些是未跟踪的，因为我们还没有使用 <code>git add</code> 添加它们。</p>
<p><strong>注意</strong>：添加也称为<strong>暂存</strong>（staging）（相当于 <code>git stage</code>）。</p>
<p>让我们再试一次添加并检查状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add tofu/basil_ginger_tofu.txt</span><br></pre></td></tr></table></figure>

<p>继续这个过程，你可以将所有需要跟踪的文件添加到 Git 仓库中，并最终提交它们来保存这些更改的历史记录。<br>接下来我们将使用命令将我们的豆腐食谱副本存入仓库（即放入保险箱）。为此，我们使用如下所示的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;add tofu recipes&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行该命令时，命令会将所有暂存的更改（在本例中是我们的豆腐食谱）拍成快照并存入仓库。由于我们没有对 seitan 食谱使用 git add，它们没有包含在存入仓库的快照中。</p>
<p>这个快照现在永远保存在仓库中（只要我们的计算机硬盘没有故障，或者我们没有损坏秘密仓库文件）。该标志允许我们向提交添加消息，以便我们记住这个提交的最重要内容（实际上 Git 不允许你在没有消息的情况下提交）。通常的惯例是使用命令形式的动词而不是过去时。例如，上面的提交消息说“add tofu recipes”而不是“added tofu recipes”。</p>
<p>另一个比喻是，你可以将整个过程想象为用相机拍全景照片。命令捕捉图像的一部分，并将所有“添加”的项目拼接成一个全景图，然后将这个全景图扔进保险箱中。正如全景图只包括你指向的内容（而不是围绕你的整个 360 度圈），该命令只包括那些使用命令添加的文件（而不是文件夹中的所有文件）。</p>
<p>提交之后，你会注意到不再列出“Changes to be committed”下的文件。这类似于当你拍完全景照片后，所有临时的小图像文件都会被丢弃。此时的结果如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        seitan/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>

<p>正如你可能从我们多次使用它中猜到的那样，<code>git status</code> 对于查看仓库中当前发生的事情非常有用。如果你遇到意外行为，这是查看的第一个地方！</p>
<p>如果你查看文件夹中的文件，你会看到提交过程并未影响我们计算机上的原始文件。这很像当你给朋友拍全景照片时，他们并不会被吸进你的手机里的网络地狱。</p>
<p>我们可以使用一个特殊的命令查看快照的证据：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 9f955d85359fc8e4504d7220f13fad34f8f2c62b</span><br><span class="line">Author: Sandra Upson &lt;sandra@Sandras-MacBook-Air.<span class="built_in">local</span>&gt;</span><br><span class="line">Date:   Sun Jan 17 19:06:48 2016 -0800</span><br><span class="line"></span><br><span class="line">    add tofu recipes</span><br></pre></td></tr></table></figure>

<p>那串巨大的字符 <code>9f955d85359fc8e4504d7220f13fad34f8f2c62b</code> 是提交的 ID。我们可以使用<code>git show</code>命令来查看这个提交的内部内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git show 9f955d85359fc8e4504d7220f13fad34f8f2c62b</span><br><span class="line"></span><br><span class="line">commit 9f955d85359fc8e4504d7220f13fad34f8f2c62b</span><br><span class="line">Author: Sandra Upson &lt;sandra@Sandras-MacBook-Air.<span class="built_in">local</span>&gt;</span><br><span class="line">Date:   Sun Jan 17 19:06:48 2016 -0800</span><br><span class="line"></span><br><span class="line">    add tofu recipes</span><br><span class="line"></span><br><span class="line">diff --git a/tofu/basil_ginger_tofu.txt b/tofu/basil_ginger_tofu.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..9a56e7a</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/tofu/basil_ginger_tofu.txt</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+basil</span><br><span class="line">+ginger</span><br><span class="line">+tofu</span><br><span class="line">diff --git a/tofu/kung_pao_tofu.txt b/tofu/kung_pao_tofu.txt</span><br><span class="line">new file mode 100644 index</span><br><span class="line">0000000..dad9bd9</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/tofu/kung_pao_tofu.txt</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+szechuan peppers</span><br><span class="line">+tofu</span><br><span class="line">+peanuts</span><br><span class="line">+kung</span><br><span class="line">+pao</span><br></pre></td></tr></table></figure>

<p>这些命令和结果展示了如何使用 Git 跟踪和管理文件的版本控制。这些基本操作是 Git 工作流程的核心部分。</p>
<p>如果我们回滚到先前提交的版本，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git restore --<span class="built_in">source</span>=9f955d85359fc8e4504d7220f13fad34f8f2c62b tofu/kung_pao_tofu.txt</span><br></pre></td></tr></table></figure>

<p>使用场景和示例</p>
<ul>
<li>取消工作目录中的修改：</li>
</ul>
<p>如果你对某个文件进行了修改，但想取消这些修改，可以使用 git restore。这会将文件恢复到上一次提交的状态。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore foo.txt <span class="comment">#这将取消对 foo.txt 所做的所有未提交的更改。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>恢复暂存区中的文件：<br>如果你想取消对暂存区中某个文件的修改，但保留工作目录中的修改，可以使用 –staged 选项。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged &lt;filename&gt;</span><br></pre></td></tr></table></figure>
示例：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged foo.txt <span class="comment">#这将把 foo.txt 从暂存区恢复到上一个提交的状态，但保留工作目录中的修改。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从特定提交恢复文件：</li>
</ul>
<p>你还可以从特定的提交恢复文件，而不是当前的最新提交。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --<span class="built_in">source</span> &lt;commit hashcode&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git restore --<span class="built_in">source</span>=9f955d85359fc8e4504d7220f13fad34f8f2c62b tofu/kung_pao_tofu.txt <span class="comment">#这将把 tofu/kung_pao_tofu.txt 恢复到&#x27;9f955d85359fc8e4504d7220f13fad34f8f2c62b&#x27;提交的状态。</span></span><br></pre></td></tr></table></figure>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><pre><code>git init
git status
git  add ./&lt;filename&gt;
git commit
git log
git show &lt;commit hash&gt;
git restore ##不破化提交记录

repo - stages - workpalce
</code></pre>
<ul>
<li>**<code>git init</code>**：创建一个盒子（仓库），永久存储全景照片（提交）。</li>
<li>**<code>git add</code>**：拍摄一个临时照片（暂存），这些照片可以稍后组装成全景照片。</li>
<li>**<code>git commit</code>**：将所有可用的临时照片（暂存的更改）组装成一张全景照片。同时销毁所有临时照片。</li>
<li>**<code>git log</code>**：列出我们拍过的所有全景照片。</li>
<li>**<code>git show</code>**：检查某张特定全景照片的内容。</li>
<li>**<code>git restore</code>**：将文件重新排列成某张全景照片中的样子。这不会影响你盒子中的全景照片。</li>
</ul>
<h3 id="本地仓库技术概览"><a href="#本地仓库技术概览" class="headerlink" title="本地仓库技术概览"></a>本地仓库技术概览</h3><p><img src="/./git.png" alt="git"><br>如图所示，文件分为两大类：</p>
<ol>
<li><p><strong>未跟踪的文件</strong>（untracked files）：这些文件要么从未被跟踪过，要么已从跟踪中移除。Git 不会为这些文件维护历史记录。</p>
</li>
<li><p><strong>已跟踪的文件</strong>（tracked files）：这些文件已添加到 Git 仓库中，可以处于不同的修改状态：未修改、已修改或已暂存。</p>
<p>a. <strong>未修改的文件</strong>（unmodified file）：自从上一个版本被添加到 Git 仓库以来，这个文件没有任何新的更改。</p>
<p>b. <strong>已修改的文件</strong>（modified file）：这个文件与 Git 保存的上一个版本不同。</p>
<p>c. <strong>已暂存的文件</strong>（staged file）：用户指定为未来提交的一部分的文件（通常通过 <code>git add</code> 命令）。我们可以将这些文件视为有灯光照射的文件。</p>
</li>
</ol>
<h4 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h4><p>Git 参考资料中有一个很好的部分关于<a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-revert#Documentation/git-revert.txt-undo">撤销操作</a>。请注意，虽然 Git 是围绕历史记录的概念而构建的，但如果你使用某些撤销命令进行还原，可能会丢失你的工作。因此，在撤销工作之前，请仔细阅读并了解更改的影响。</p>
<ul>
<li><p><strong>将尚未提交的文件取消暂存</strong>：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged [file]</span><br></pre></td></tr></table></figure>

<p>  这会将文件的状态恢复为已修改状态，保留更改。不要担心这个命令会撤销任何工作。这个命令相当于删除你将要组合成全景图的临时图像之一。</p>
<p>  为什么我们需要使用这个命令？假设你不小心开始跟踪了一个你不想跟踪的文件（例如，一个尴尬的自己的视频）。或者你对一个文件进行了修改，原本打算提交但现在不想提交。</p>
</li>
<li><p><strong>修改最新的提交（更改提交信息或添加遗忘的文件）</strong>：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add [forgotten-file]</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>  请注意，这个新的修订提交将替换之前的提交。</p>
</li>
<li><p><strong>恢复文件到最近一次提交时的状态（谨慎使用！）</strong>：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore [file]</span><br></pre></td></tr></table></figure>

<p>  如果文件已经暂存，你需要先取消暂存。</p>
<p>  这个命令在你希望合法地撤销你的工作时非常有用。例如，如果你在之前提交后意外修改了某个文件，并希望将其恢复到之前的状态。</p>
<p>  使用这个命令要小心！自上次提交以来对文件所做的任何更改都将丢失。如果你想安全一些，先暂存并提交你的更改，然后使用以下命令之一将其恢复到之前的版本。</p>
</li>
</ul>
<h4 id="获取文件的先前版本"><a href="#获取文件的先前版本" class="headerlink" title="获取文件的先前版本"></a>获取文件的先前版本</h4><p>假设你正在进行一个实验，做到一半时，你发现自己完全做错了。如果有一种方法可以取回初始代码，这样你就可以重新开始了！</p>
<p>如果你还没有提交，你可以使用前面的命令 —— 但是如果你已经提交了一些更改呢？与其恢复到最新的提交，你可以使用更强大的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --<span class="built_in">source</span>=[commit or branch] [file or folder]</span><br></pre></td></tr></table></figure>

<p>这个命令可以从任意时间点获取文件。例如，假设你意外删除了 <code>lab1000/</code> 并提交了这个更改。哦不！为了修复这个问题，你可以使用以下命令取回初始代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --<span class="built_in">source</span>=skeleton/main lab1000/</span><br></pre></td></tr></table></figure>

<p>这允许你从 <code>lab1000/</code> 的初始代码重新开始。</p>
<p>现在考虑一个情景，你在 <code>lab1000/Cheese.txt</code> 上做了一些进展，并希望取回几次提交前的版本。你可以找到包含我们想要恢复版本的正确提交 ID，然后运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> lab1000/Cheese.txt</span><br></pre></td></tr></table></figure>

<p>找出正确的提交 ID 后，运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --<span class="built_in">source</span>=abcd1234efgh7890abcd1234c7ee5e7890c7ee5e lab1000/Cheese.txt</span><br></pre></td></tr></table></figure>

<p>其中 <code>abcd1234efgh7890abcd1234c7ee5e7890c7ee5e</code> 是包含我们想要恢复版本的提交 ID。</p>
<p>记住，你需要重新暂存文件，以便在下次提交时跟踪你的恢复操作！</p>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li>**<code>git clone [remote-repo-URL]</code>**：在本地计算机上创建指定仓库的副本。还会创建一个工作目录，该目录中的文件排列方式与下载仓库中的最新快照完全相同。同时记录远程仓库的 URL，以便后续的网络数据传输，并给它一个特殊的远程仓库名称 **<code>origin</code>**。</li>
<li>**<code>git remote add [remote-repo-name] [remote-repo-URL]</code>**：记录网络数据传输的新位置。</li>
<li>**<code>git remote -v</code>**：列出所有网络数据传输的位置。</li>
<li>**<code>git pull [remote-repo-name] main</code>**：获取文件的最新副本，如 .remote-repo-name 中所示。</li>
<li>**<code>git push [remote-repo-name] main</code>**：将文件的最新副本上传到 .remote-repo-name。</li>
</ul>
<h3 id="Git分支（高级Git）"><a href="#Git分支（高级Git）" class="headerlink" title="Git分支（高级Git）"></a>Git分支（高级Git）</h3><p><strong>注意</strong>：在 2020 年，Git 将默认分支名称从 <code>master</code> 更改为 <code>main</code>。下面的图示尚未相应更新 —— 目前，只需将 <code>master</code> 视为 <code>main</code> 的旧版等价物。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master  main</span><br></pre></td></tr></table></figure>

<p><img src="/./branch1.png" alt="Git Branch Illustration"></p>
<p>到目前为止，我们所覆盖的每个命令都在默认分支上工作。这个分支通常被称为 <code>main</code> 分支。然而，有时候你可能需要在代码中创建分支。</p>
<p>分支允许你同时跟踪工作中的多个不同版本。你可以将分支视为平行的维度。也许一个分支是选择使用链表的结果，而另一个分支是选择使用数组的结果。</p>
<p><img src="/./branch2.png" alt="Git Branch Illustration"></p>
<h3 id="分支的原因"><a href="#分支的原因" class="headerlink" title="分支的原因"></a>分支的原因</h3><p>以下是一些可能需要创建分支的情况：</p>
<ul>
<li>你可能想对现有代码进行重大更改（称为重构），但这会破坏项目的其他部分。然而，你希望能够同时处理其他部分，或者你有合作伙伴，并且你不想破坏他们的代码。</li>
<li>你想开始处理项目的新部分，但你不确定这些更改是否可行，并最终成为成品的一部分。</li>
<li>你与合作伙伴一起工作，并且不想将当前的工作与他们的混在一起，即使你希望将来能够把所有的工作结合在一起。</li>
</ul>
<p>创建分支可以让你同时跟踪工作中的多个不同版本，并且可以轻松地在版本之间切换和合并分支。一旦你完成了某个部分的工作，并希望将其合并到主代码中，你就可以进行合并操作。</p>
<h3 id="一个示例场景"><a href="#一个示例场景" class="headerlink" title="一个示例场景"></a>一个示例场景</h3><p>例如，假设你已经完成了一个项目的一半。还有一个困难的部分需要完成，你不确定如何完成。也许你有三种不同的想法，但你不确定哪一种会奏效。在这种情况下，创建一个分支来尝试第一个想法可能是个好主意。</p>
<ul>
<li>如果你的代码有效，你可以将分支合并回主代码（在 <code>main</code> 分支上）并提交你的项目。</li>
<li>如果你的代码无效，不用担心撤销代码和修改 Git 历史。你可以简单地切换回 <code>main</code> 分支，该分支不会包含任何更改，然后创建另一个分支并尝试第二个想法。</li>
</ul>
<p>你可以这样持续操作，直到找到最佳的代码编写方式，然后只需在最后将工作有效的分支合并回主分支。</p>
<p>Git 参考资料中有一个关于<a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging">分支和合并</a>的部分，其中有关于分支如何在 Git 的底层数据结构中表示的一些图示。实际上，Git 将提交历史作为图表来跟踪，其中包含分支指针和作为图表节点的提交（因此有了与树相关的术语）。</p>
<h3 id="创建、删除和切换分支"><a href="#创建、删除和切换分支" class="headerlink" title="创建、删除和切换分支"></a>创建、删除和切换分支</h3><p>一个特殊的分支指针称为 <code>HEAD</code>，它引用当前作为工作目录的分支。分支指令会修改分支并更改 <code>HEAD</code> 指向的内容，以便你看到文件的不同版本。</p>
<ul>
<li><p>以下命令将基于当前分支创建一个新分支：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [new-branch-name]</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个命令允许你在分支之间切换，改变 <code>HEAD</code> 指向的分支：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [branch-name]</span><br></pre></td></tr></table></figure>

<p>  示例：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建分支让你可以同时处理代码的不同版本，并且可以在完成部分工作后轻松地合并分支，从而保持代码的整洁和有序。</p>
<h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>有时候你可能想将一个分支合并到另一个分支。例如，假设你对 <code>fixing-ai-heuristics</code> 分支上的工作非常满意。你的 AI 现在非常棒，你希望你的主分支能够看到你在 <code>fixing-ai-heuristics</code> 分支上所做的提交，并删除 <code>fixing-ai-heuristics</code> 分支。<br><img src="/./merge.png" alt="merge"></p>
<p>在这种情况下，你应该切换到 <code>main</code> 分支，并将 <code>fixing-ai-heuristics</code> 分支合并到 <code>main</code> 分支：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch main</span><br><span class="line">$ git merge fixing-ai-heuristics</span><br></pre></td></tr></table></figure>

<p>这个命令将创建一个新的提交，将两个分支合并在一起，并更改每个分支的指针以引用这个新的提交。虽然大多数提交只有一个父提交，但这个新的合并提交有两个父提交。<code>main</code> 分支上的提交被称为它的第一个父提交，而 <code>fixing-ai-heuristics</code> 分支上的提交被称为它的第二个父提交。<br><img src="/./merge1.png" alt="merge"></p>
<h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>当你尝试合并两个分支时，可能会发生信息冲突。这种情况可能发生在两个分支的提交更改了相同的文件。Git 足够智能，可以解决许多更改，即使它们发生在同一个文件中的不同地方。</p>
<p>然而，有时候冲突无法通过 Git 解决，因为更改影响了代码中的相同方法或行。在这种情况下，它会将不同分支中的更改呈现给你，作为合并冲突。</p>
<h3 id="合并的示例图示"><a href="#合并的示例图示" class="headerlink" title="合并的示例图示"></a>合并的示例图示</h3><p>上图显示了从 <code>fixing-ai-heuristics</code> 分支合并到 <code>main</code> 分支的示例。在合并之后，新的合并提交（C6）会有两个父提交（C5 和 <code>fixing-ai-heuristics</code> 分支上的最新提交）。</p>
<p>合并之后，你可以继续在 <code>main</code> 分支上进行开发，而 <code>fixing-ai-heuristics</code> 分支上的更改已经被合并到主代码库中。如果发生合并冲突，你需要手动解决这些冲突，然后提交合并结果。</p>
<h3 id="G-远程仓库（高级）"><a href="#G-远程仓库（高级）" class="headerlink" title="G. 远程仓库（高级）"></a>G. 远程仓库（高级）</h3><h4 id="私有仓库-vs-公共仓库"><a href="#私有仓库-vs-公共仓库" class="headerlink" title="私有仓库 vs 公共仓库"></a>私有仓库 vs 公共仓库</h4><p>默认情况下，GitHub 上的仓库是公共的，而不是私有的。这意味着在公共仓库中，互联网上的任何人都可以查看代码。对于所有课程作业，要求使用私有仓库。</p>
<p>从 2019 年 1 月 7 日起，GitHub 提供免费无限制的私有仓库，因此没有理由将代码发布在公共仓库中。</p>
<h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>添加远程仓库意味着你告诉 Git 仓库的位置。你不一定对每个添加的仓库都有读&#x2F;写访问权限。实际上访问和修改远程仓库中的文件将在稍后讨论，并依赖于已添加的远程仓库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [short-name] [remote-url]</span><br></pre></td></tr></table></figure>

<p>远程 URL 看起来像这样，如果你使用 HTTP 或 SSH：</p>
<ul>
<li><code>https://github.com/berkeley-cs61b/skeleton.git</code></li>
<li><code>git@github.com:berkeley-cs61b/skeleton.git</code></li>
</ul>
<p>按照惯例，主远程仓库的名称被称为 <code>origin</code>（原始远程仓库）。因此，以下两个命令中的任意一个都可以让我将仓库添加为远程仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/berkeley-cs61b/skeleton.git</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:berkeley-cs61b/skeleton.git</span><br></pre></td></tr></table></figure>

<p>添加远程仓库后，所有其他命令都使用其关联的简称。</p>
<h4 id="重命名、删除和列出远程仓库"><a href="#重命名、删除和列出远程仓库" class="headerlink" title="重命名、删除和列出远程仓库"></a>重命名、删除和列出远程仓库</h4><ul>
<li><p>你可以使用以下命令重命名远程仓库：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename [old-name] [new-name]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不再使用远程仓库，你也可以将其删除：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> [remote-name]</span><br></pre></td></tr></table></figure>
</li>
<li><p>要查看你有哪些远程仓库，你可以列出它们。<code>-v</code> 标志会告诉你每个远程仓库的 URL（不仅仅是它们的名称）。</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li>
</ul>
<p>你可以在 Pro Git 书中阅读更多关于<a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes">远程仓库工作</a>的信息。</p>
<h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>通常，你会希望将远程仓库中的代码复制到自己的计算机上。在这些情况下，你可以通过克隆远程仓库轻松下载整个仓库及其提交历史：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [remote-url]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [remote-url] [directory-name]</span><br></pre></td></tr></table></figure>

<p>第一个命令会创建一个与远程仓库同名的目录。第二个命令允许你为复制的仓库指定一个不同的名称。</p>
<p>当你克隆一个远程仓库时，克隆的远程仓库会默认与本地仓库关联，名称为 <code>origin</code>。这是默认的，因为克隆的远程仓库是你本地仓库的初始来源。</p>
<h3 id="推送提交"><a href="#推送提交" class="headerlink" title="推送提交"></a>推送提交</h3><p>你可能希望通过添加一些本地创建的提交来更新远程仓库的内容。你可以通过推送提交来实现这一点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [remote-branch]</span><br></pre></td></tr></table></figure>

<p>请注意，你将从指针当前引用的分支推送到远程分支。例如，假设我克隆了一个仓库并在 <code>main</code> 分支上进行了一些更改。我可以使用以下命令将我的本地更改推送到远程仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure>

<h3 id="获取和拉取提交"><a href="#获取和拉取提交" class="headerlink" title="获取和拉取提交"></a>获取和拉取提交</h3><p>有时候你可能希望从远程仓库获取一些新的提交，而这些提交目前不在你的本地仓库中。例如，你可能克隆了一个由合作伙伴创建的远程仓库，并希望获取他&#x2F;她最新的更改。你可以通过从远程仓库获取或拉取这些更改来实现这一点。</p>
<h4 id="fetch：这相当于下载提交。它不会将它们合并到你的代码中。"><a href="#fetch：这相当于下载提交。它不会将它们合并到你的代码中。" class="headerlink" title="fetch：这相当于下载提交。它不会将它们合并到你的代码中。"></a>fetch：这相当于下载提交。它不会将它们合并到你的代码中。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote-name]</span><br></pre></td></tr></table></figure>

<p>你为什么会使用这个命令？你的合作伙伴可能已经做了一些更改，你希望审查这些更改但将它们与自己的代码分开。获取更改只会更新你本地的远程代码副本，但不会将更改合并到你自己的代码中。</p>
<p>例如，假设你的合作伙伴在远程仓库上创建了一个名为 <code>fixing-ai-heuristics</code> 的新分支。你可以通过以下步骤查看该分支的提交：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git branch review-ai-fix origin/fixing-ai-heuristics</span><br><span class="line">git switch review-ai-fix</span><br></pre></td></tr></table></figure>

<p>第二个命令创建一个名为 <code>review-ai-fix</code> 的新分支，该分支跟踪远程分支 <code>origin/fixing-ai-heuristics</code>。</p>
<h4 id="pull：这相当于-fetch-和-merge-的组合。它不仅会获取最新的更改，还会将这些更改合并到你的分支中。"><a href="#pull：这相当于-fetch-和-merge-的组合。它不仅会获取最新的更改，还会将这些更改合并到你的分支中。" class="headerlink" title="pull：这相当于 fetch 和 merge 的组合。它不仅会获取最新的更改，还会将这些更改合并到你的分支中。"></a>pull：这相当于 <code>fetch</code> 和 <code>merge</code> 的组合。它不仅会获取最新的更改，还会将这些更改合并到你的分支中。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [remote-name] [remote-branch-name]</span><br></pre></td></tr></table></figure>

<p>假设我的老板伙伴推送了一些提交到我们的共享远程仓库的分支，这些提交修复了我们的 AI 启发式方法。我知道这些更改不会破坏我的代码，所以我可以立即将其拉取并合并到我的代码中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>

<p>通过使用 <code>pull</code> 命令，我可以获取远程仓库中的最新更改并将其合并到我本地的分支中。</p>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>使用这两个命令设置 Git 将使用的名称和电子邮件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;&lt;你的名字&gt;&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&lt;你的电子邮件&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>设置 Git 的默认分支名称：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global init.defaultBranch main</span><br></pre></td></tr></table></figure>

<p>设置“合并策略”：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global pull.rebase <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><code>git push</code> 是将本地仓库中的提交推送到远程仓库。具体来说，它将本地仓库的某个分支的提交记录（也就是本地的 commit 历史）推送到远程仓库的对应分支。</p>
<p>以下是更详细的解释：</p>
<h3 id="Git-的三个主要区域"><a href="#Git-的三个主要区域" class="headerlink" title="Git 的三个主要区域"></a>Git 的三个主要区域</h3><ol>
<li><p><strong>工作区（Working Directory）</strong>：</p>
<ul>
<li>这是你实际编辑文件的地方。</li>
</ul>
</li>
<li><p><strong>暂存区（Staging Area）</strong>：</p>
<ul>
<li>当你用 <code>git add</code> 命令将文件添加到暂存区时，这些文件准备好被提交。</li>
</ul>
</li>
<li><p><strong>本地仓库（Local Repository）</strong>：</p>
<ul>
<li>当你用 <code>git commit</code> 命令提交时，暂存区的所有文件被提交到本地仓库，形成一个新的提交（commit）。</li>
</ul>
</li>
</ol>
<h4 id="git-push-的工作原理"><a href="#git-push-的工作原理" class="headerlink" title="git push 的工作原理"></a><code>git push</code> 的工作原理</h4><ul>
<li><strong>本地提交</strong>：<code>git push</code> 是将已经在本地仓库中的提交推送到远程仓库。换句话说，只有已经用 <code>git commit</code> 提交到本地仓库的更改才会被 <code>git push</code> 推送到远程仓库。</li>
<li><strong>推送操作</strong>：<code>git push</code> 不会直接从暂存区推送文件。它推送的是本地仓库中某个分支的提交记录。</li>
</ul>
<h3 id="工作流程示例"><a href="#工作流程示例" class="headerlink" title="工作流程示例"></a>工作流程示例</h3><ol>
<li><p><strong>编辑文件</strong>：在工作区中修改文件。</p>
</li>
<li><p><strong>暂存更改</strong>：使用 <code>git add</code> 命令将修改的文件添加到暂存区。</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提交更改</strong>：使用 <code>git commit</code> 命令将暂存区的文件提交到本地仓库。</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;描述更改内容的提交信息&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>推送到远程仓库</strong>：使用 <code>git push</code> 命令将本地仓库中的提交推送到远程仓库。</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<p> 例如，推送到名为 <code>origin</code> 的远程仓库的 <code>main</code> 分支：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>git push</code> 是将本地仓库中的提交记录推送到远程仓库。</li>
<li>只有已经用 <code>git commit</code> 提交到本地仓库的更改才会被 <code>git push</code> 推送到远程仓库。</li>
<li><code>git push</code> 不会直接从暂存区推送文件，而是推送已经在本地仓库中的提交记录。</li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul>
<li>JDK：用于开发 Java 应用程序，包含编译器、运行时环境、类库和开发工具。</li>
<li>JAR：用于分发和部署 Java 应用程序或类库的归档文件格式，可以包含多个 .class 文件和资源文件。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/07/cs61b-lab01/" data-id="clyb7odzb0000iota5alw0fqm" data-title="cs61b-lab01" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-makefile" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/03/makefile/" class="article-date">
  <time class="dt-published" datetime="2024-07-03T03:10:52.000Z" itemprop="datePublished">2024-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/03/makefile/">Makefile与CMake（于仕琪老师笔记）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h1><h2 id="1-常见的c-编译指令"><a href="#1-常见的c-编译指令" class="headerlink" title="1 常见的c++编译指令"></a>1 常见的c++编译指令</h2><p><code>g++ &lt;*.cpp *.cpp..(源代码文件)&gt; -o &lt;可执行文件文件名&gt; </code></p>
<p><code>g++ &lt;*.cpp *.cpp..(源代码文件)&gt; -c &lt;*.o文件，只经过编译，未链接的文件，名字是源代码的文件名&gt;</code></p>
<p><code>g++ *.o -o &lt;可执行文件名&gt;</code> 将所有的.o文件链接成可执行文件</p>
<ul>
<li>为什么使用 -c 编译；而不是使用编译链接一步完成的方式？</li>
</ul>
<p>对源代码文件执行 -c 编译的好处在于：如果我们修改了某个源文件，我们在编译时，只需要对被修改的文件执行 -c 编译（编译为.o 文件），当确定所有文件无误后，进行链接，而不用像编译链接一步完成，之后对其中的少数几个文件修改后，需要对所有源代码文件进行重新编译，当文件数量很多时，一次编译会花上数个小时的时间，-c 编译会极大的提高效率。<br><code>-Wall</code>，显示所有的warning。</p>
<ul>
<li>makefile意义</li>
</ul>
<p>当源代码文件有非常多时，在命令行中输入单条指令变得繁琐，我们可以将这些命令写在一个脚本文件中，这种脚本文件有特定的格式–makefile。</p>
<h2 id="2-Makefile"><a href="#2-Makefile" class="headerlink" title="2 Makefile"></a>2 Makefile</h2><h3 id="version-1"><a href="#version-1" class="headerlink" title="version 1"></a>version 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello: main.cpp printhello.cpp factorial.cpp</span><br><span class="line">    g++ -o hello main.cpp printhello.cpp factorial.cpp</span><br></pre></td></tr></table></figure>
<p> <strong>g++前必须加一个tab，不能是空格</strong><br> 上面的tab符的意义：我要生成的目标为：<code>hello</code>；它依赖于<code>main.cpp printhello.cpp factorial.cpp</code>，使用<code>g++ -o hello main.cpp printhello.cpp factorial.cpp</code>命令生成这个目标。<br>makefile文件完成以后，在当前目录下使用<code>make</code>命令，（make命令会自动去找当前文件下的Makefile文件，如果文件名不是Makefile，可以使用命令<code>make -f &lt;Makefile文件名&gt;</code>指定文件名）.</p>
<p>如果多次使用make命令，make会检查每个源代码的文件的生成时间，如果生成时间晚于目标生成时间，则执行Makefile脚本，如果不存在，则不执行编译。</p>
<ul>
<li>缺点在于，使用编译链接一步完成。</li>
</ul>
<h3 id="version-2"><a href="#version-2" class="headerlink" title="version 2"></a>version 2</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJ)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">printhello.o: printhello.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c printhello.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">factorial.o: factorial.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -c factorial.cpp</span><br></pre></td></tr></table></figure>
<ul>
<li>优点：编译链接分开，源文件修改后，只需要编译修改过的源文件</li>
</ul>
<h3 id="version-3"><a href="#version-3" class="headerlink" title="version 3"></a>version 3</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">OBJ = main.o printhello.o factorial.o </span><br><span class="line"><span class="comment"># 需要加入文件时，在这里加入.o文件就行</span></span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> </span><br><span class="line"><span class="comment"># $@代表$(TARGET)，$^代表$(OBJ),$^ 尖尖朝上，依赖中的所有项，尖尖朝左，指依赖中的第一项。</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp #百分号是什么意思</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean: #目标：依赖，的意思</span></span><br><span class="line">    rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<h3 id="version-4"><a href="#version-4" class="headerlink" title="version 4"></a>version 4</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = hello</span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span> </span><br><span class="line"><span class="comment"># 将当前目录下的所有cpp文件拿来编译，新增就会编译，SRC：使用 wildcard 函数查找当前目录下所有的 .cpp 文件，并将其存储在 SRC 变量中。</span></span><br><span class="line">OBJ = 4(patsubst %.cpp,%.o,<span class="variable">$(SRC)</span>)</span><br><span class="line"><span class="comment"># OBJ：使用 patsubst 函数将所有的 .cpp 文件名替换为 .o 文件名（对象文件名），并将结果存储在 OBJ 变量中。</span></span><br><span class="line"></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJ)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span> </span><br><span class="line"><span class="comment"># $@：自动变量，表示规则中的目标文件名，这里是 hello。</span></span><br><span class="line"><span class="comment"># $^：自动变量，表示所有的依赖文件，这里是所有的 .o 文件。</span></span><br><span class="line"><span class="section">%.o: %.cpp </span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># %.o: %.cpp：通配符规则，表示如何从 .cpp 文件生成对应的 .o 文件。</span></span><br><span class="line"><span class="comment"># $&lt;：自动变量，表示第一个依赖文件，这里是对应的 .cpp 文件。</span></span><br><span class="line"><span class="comment"># $@：自动变量，表示目标文件名，这里是对应的 .o 文件。</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean: </span></span><br><span class="line">    rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<h2 id="GPT："><a href="#GPT：" class="headerlink" title="GPT："></a>GPT：</h2><h3 id="符号"><a href="#符号" class="headerlink" title="$符号"></a><code>$</code>符号</h3><p>在<code>Makefile</code>中，<code>$</code>符号用于引用变量和自动变量。</p>
<ul>
<li><strong>变量引用</strong>：用来引用之前定义的变量。例如，<code>$(CXX)</code>引用了变量<code>CXX</code>的值。</li>
<li><strong>自动变量</strong>：用来引用规则中的目标文件或依赖文件，具体会在后面详细解释。</li>
</ul>
<h3 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h3><p>自动变量是<code>Makefile</code>中的特殊变量，用于在规则中引用目标文件和依赖文件。常见的自动变量包括：</p>
<ul>
<li>**<code>$@</code>**：表示规则中的目标文件名。例如，在规则<code>%.o: %.cpp</code>中，<code>$@</code>表示生成的<code>.o</code>文件名。</li>
<li>**<code>$&lt;</code>**：表示第一个依赖文件名。例如，在规则<code>%.o: %.cpp</code>中，<code>$&lt;</code>表示被编译的<code>.cpp</code>文件名。</li>
<li>**<code>$^</code>**：表示所有的依赖文件名列表，包含重复的文件名。例如，在<code>$(TARGET): $(OBJ)</code>规则中，<code>$^</code>表示所有的<code>.o</code>文件名。</li>
<li>**<code>$?</code>**：表示所有比目标文件更新的依赖文件名列表。</li>
</ul>
<h3 id="通配符规则"><a href="#通配符规则" class="headerlink" title="通配符规则"></a>通配符规则</h3><p>通配符规则是<code>Makefile</code>中的一种模式规则，用于定义一组文件的生成方式。通配符规则使用百分号<code>%</code>作为通配符，表示任意字符序列。常见的通配符规则包括：</p>
<ul>
<li>**<code>%.o: %.cpp</code>**：表示所有的<code>.o</code>文件可以通过相应的<code>.cpp</code>文件生成。这里的<code>%</code>表示通配符，匹配文件名的任意部分。</li>
</ul>
<p>具体来看，这段规则和命令的意思是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**<code>%.o: %.cpp</code>**：表示匹配任意文件名的<code>.cpp</code>文件（例如<code>foo.cpp</code>），生成相应的<code>.o</code>文件（例如<code>foo.o</code>）。</li>
<li>**<code>$(CXX)</code>**：变量，表示C++编译器。</li>
<li>**<code>$(CXXFLAGS)</code>**：变量，表示编译标志。</li>
<li>**<code>$&lt;</code>**：自动变量，表示第一个依赖文件（即源文件<code>foo.cpp</code>）。</li>
<li>**<code>$@</code>**：自动变量，表示目标文件（即生成的对象文件<code>foo.o</code>）。</li>
</ul>
<p>这条规则的意思是：将所有的<code>.cpp</code>文件编译成相应的<code>.o</code>文件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>$</code>符号</strong>：用于引用变量和自动变量。</li>
<li><strong>自动变量</strong>：特殊变量，用于引用规则中的目标文件和依赖文件，例如<code>$@</code>、<code>$&lt;</code>和<code>$^</code>。</li>
<li><strong>通配符规则</strong>：使用<code>%</code>作为通配符，定义一组文件的生成方式，例如<code>%.o: %.cpp</code>表示所有<code>.o</code>文件由相应的<code>.cpp</code>文件生成。</li>
</ul>
<p>这些特性使得<code>Makefile</code>在处理大量文件时非常灵活和高效。</p>
<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><p>Makefile是无法移植的，CMake是跨平台的<br>CMake文名：CMakeLists </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line">project(hello)</span><br><span class="line">add_executable(hello main.cpp factorial.cpp printhello.cpp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cmake会根据CMakelists我们生成优秀的makefile。<br>但是cmake会生成很多文件，难以管理，我们可以创建一个build 目录，转这个目录下执行上层目录的cmakelists，生成的文件在此目录下。这也就是很多ide中会生成一个build目录，（QT）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/03/makefile/" data-id="cly5cpit100005kta7ndjby8b" data-title="Makefile与CMake（于仕琪老师笔记）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-GDB" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/02/GDB/" class="article-date">
  <time class="dt-published" datetime="2024-07-02T14:02:58.000Z" itemprop="datePublished">2024-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/02/GDB/">GDB</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/02/GDB/" data-id="cly4inq220000d4ta29juch1h" data-title="GDB" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构(CS61B)md" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(CS61B)md/" class="article-date">
  <time class="dt-published" datetime="2024-06-28T14:32:56.000Z" itemprop="datePublished">2024-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(CS61B)md/">数据结构(CS61B)-图.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="lecture-23-Graph-Traversals-and-Implementations"><a href="#lecture-23-Graph-Traversals-and-Implementations" class="headerlink" title="lecture 23 Graph Traversals and Implementations"></a>lecture 23 Graph Traversals and Implementations</h1><h2 id="图论基础知识"><a href="#图论基础知识" class="headerlink" title="图论基础知识"></a>图论基础知识</h2><h3 id="1-图是一个在现实生活中更为常见的数据结构："><a href="#1-图是一个在现实生活中更为常见的数据结构：" class="headerlink" title="1 图是一个在现实生活中更为常见的数据结构："></a>1 图是一个在现实生活中更为常见的数据结构：</h3><table>
<thead>
<tr>
<th>应用</th>
<th>节点</th>
<th>连接</th>
</tr>
</thead>
<tbody><tr>
<td>地图</td>
<td>十字路口</td>
<td>公路</td>
</tr>
<tr>
<td>网络内容</td>
<td>网页</td>
<td>超链接</td>
</tr>
<tr>
<td>电路</td>
<td>元器件</td>
<td>导线</td>
</tr>
<tr>
<td>任务调度</td>
<td>任务</td>
<td>限制条件</td>
</tr>
</tbody></table>
<p><strong>图</strong>：由顶点和边组成的数据结构。在图中，顶点（节点）通过边（连接）相互连接。边与路径的不同，边是否直接相连；路径是指从一个顶点到另一个顶点所经过的边的序列。</p>
<ul>
<li>路径：由边顺序连接的一系列顶点。</li>
</ul>
<p>A-&gt;B-&gt;A，是一条路径，但是不是简单路径。因为其中的A重复了两次。</p>
<p>A-&gt;B-&gt;C-&gt;B-&gt;A,是一条路径，但是不是简单路径。</p>
<ul>
<li>简单路径：是一条没有重复顶点的路径。</li>
</ul>
<p>A-&gt;B-&gt;C,是一条简单路径。<br>A-&gt;B-&gt;C-&gt;B，不是一条简单路径，但是是一条路径。</p>
<ul>
<li>环(Cycle)：是一条 <strong>至少含有一条边且起点和终点相同的</strong> 路径。</li>
</ul>
<p>A-&gt;B-&gt;A,是一条路径，由于他的起点和终点相同，所以是一个环。</p>
<ul>
<li>简单环：是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。</li>
</ul>
<p>A-&gt;B-&gt;A,在有向图中，是一个简单环，在无向图中不是一个简单环。（有待商榷）</p>
<p>A-&gt;B-&gt;C-&gt;A，是一个简单环</p>
<ul>
<li><p>路径或环的长度为其中所包含的边数。</p>
</li>
<li><p><strong>简单图</strong>：没有自环和平行边的图。</p>
</li>
<li><p><strong>自环</strong>：一个顶点到自身的<strong>边</strong>。在简单图中，自环是不允许的，但路径中可以包含从自身到自身的顶点，这种<strong>路径</strong>称为一个环。</p>
</li>
<li><p><strong>平行边</strong>：两个顶点之间有多条边。在简单图中，两顶点之间只允许有一条边。 无向图只能有一条边，允许有向图中的两点之间方向不同的两条边。</p>
</li>
<li><p><strong>连通图</strong>：图中任选两点他们之间都有路径，则是连通图。一个非连通的图由若干连通的部分组成，（连通的部分）他们都是其<strong>极大连通子图</strong>（连通分量）。</p>
</li>
<li><p><strong>树</strong>：是一幅无<strong>环连通图</strong>，互不相连的树组成的集合成为森林。<strong>连通图的生成树是他的一幅连通子图</strong>，它含有图中所有顶点且是一棵树。<strong>图的生成树森林是它的所有连通子图的生成树的集合</strong>。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(CS61B)md/" data-id="clxytnkkh00019wtacd001ak6" data-title="数据结构(CS61B)-图.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/06/28/hello-world/" class="article-date">
  <time class="dt-published" datetime="2024-06-28T13:32:26.617Z" itemprop="datePublished">2024-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/06/28/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/06/28/hello-world/" data-id="clxytnkke00009wtad48wchgg" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/07/cs61b-lab01/">cs61b-lab01</a>
          </li>
        
          <li>
            <a href="/2024/07/03/makefile/">Makefile与CMake（于仕琪老师笔记）</a>
          </li>
        
          <li>
            <a href="/2024/07/02/GDB/">GDB</a>
          </li>
        
          <li>
            <a href="/2024/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(CS61B)md/">数据结构(CS61B)-图.md</a>
          </li>
        
          <li>
            <a href="/2024/06/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>