<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>cs61b-lab01 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Lab01:Setup - gitGitGit简介Git 是一种分布式版本控制系统，而不是集中式版本控制系统。这意味着每个开发人员的计算机 存储整个项目的整个历史记录（包括所有旧版本）！这与Dropbox等工具不同，在Dropbox中，旧版本存储在一个 其他人拥有的远程服务器。我们把整个历史称为一个整体 项目 A “存储库”。存储库存储在本地的事实导致 我们能够在自己的计算机上本地使用 Git，即">
<meta property="og:type" content="article">
<meta property="og:title" content="cs61b-lab01">
<meta property="og:url" content="http://example.com/2024/07/07/cs61b-lab01/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Lab01:Setup - gitGitGit简介Git 是一种分布式版本控制系统，而不是集中式版本控制系统。这意味着每个开发人员的计算机 存储整个项目的整个历史记录（包括所有旧版本）！这与Dropbox等工具不同，在Dropbox中，旧版本存储在一个 其他人拥有的远程服务器。我们把整个历史称为一个整体 项目 A “存储库”。存储库存储在本地的事实导致 我们能够在自己的计算机上本地使用 Git，即">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/git.png">
<meta property="og:image" content="http://example.com/branch1.png">
<meta property="og:image" content="http://example.com/branch2.png">
<meta property="og:image" content="http://example.com/merge.png">
<meta property="og:image" content="http://example.com/merge1.png">
<meta property="article:published_time" content="2024-07-07T03:15:46.000Z">
<meta property="article:modified_time" content="2024-07-07T07:25:48.461Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/git.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-cs61b-lab01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/07/cs61b-lab01/" class="article-date">
  <time class="dt-published" datetime="2024-07-07T03:15:46.000Z" itemprop="datePublished">2024-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      cs61b-lab01
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Lab01-Setup-git"><a href="#Lab01-Setup-git" class="headerlink" title="Lab01:Setup - git"></a>Lab01:Setup - git</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h3><p>Git 是一种分布式版本控制系统，而不是集中式版本控制系统。这意味着每个开发人员的计算机 存储整个项目的整个历史记录（包括所有旧版本）！这与Dropbox等工具不同，在Dropbox中，旧版本存储在一个 其他人拥有的远程服务器。我们把整个历史称为一个整体 项目 A “存储库”。存储库存储在本地的事实导致 我们能够在自己的计算机上本地使用 Git，即使没有互联网连接。</p>
<h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>现在我们有一些文件(四个食谱，两个是豆腐的，两个是 seitan 的)。要设置我们的 <em><strong>Git 仓库</strong></em> 以便存储这些文件(食谱)的<em><strong>历史</strong></em>，我们需要使用以下命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /users/sandra/recipes</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>这会告诉 Git 版本控制系统，我们希望跟踪当前目录（在本例中为 recipes 目录）的历史。然而，<strong>此时，仓库中没有任何内容。这就像我们购买了一个保险箱</strong>，但还没有放入任何东西。<code>git init /users/sandra/recipes</code></p>
<p>为了将所有内容存储到仓库中，我们首先需要添加文件。例如，我们可以执行以下操作：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add tofu/kung_pao_tofu.txt</span><br></pre></td></tr></table></figure>

<p>现在这里就是 Git 开始显得有些奇怪的地方了。即使在调用这个命令之后，我们<strong>仍然</strong>没有将我们的<strong>食谱存储到仓库中（即保险箱中）</strong>。相反，<strong>我们所做的是将文件添加到要跟踪的文件列表中（即稍后要添加到保险箱中）。这个想法是你可能并不想跟踪文件夹中的每一个文件，所以该命令告诉 Git 应该跟踪哪些文件</strong>。我们可以使用以下命令查看这个命令的效果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>在这种情况下，你会看到以下响应：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">On branch main</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        new file:   tofu/kung_pao_tofu.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        seitan/</span><br><span class="line">        tofu/basil_ginger_tofu.txt</span><br></pre></td></tr></table></figure>

<p><strong>输出中的“Changes to be committed”部分列出了所有当前被跟踪并且其更改已准备好提交（即已准备好放入保险箱）的文件</strong>。我们还看到有一些未跟踪的文件；即文件夹和文件。这些是未跟踪的，因为我们还没有使用 <code>git add</code> 添加它们。</p>
<p><strong>注意</strong>：添加也称为<strong>暂存</strong>（staging）（相当于 <code>git stage</code>）。</p>
<p>让我们再试一次添加并检查状态：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add tofu/basil_ginger_tofu.txt</span><br></pre></td></tr></table></figure>

<p>继续这个过程，你可以将所有需要跟踪的文件添加到 Git 仓库中，并最终提交它们来保存这些更改的历史记录。<br>接下来我们将使用命令将我们的豆腐食谱副本存入仓库（即放入保险箱）。为此，我们使用如下所示的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;add tofu recipes&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行该命令时，命令会将所有暂存的更改（在本例中是我们的豆腐食谱）拍成快照并存入仓库。由于我们没有对 seitan 食谱使用 git add，它们没有包含在存入仓库的快照中。</p>
<p>这个快照现在永远保存在仓库中（只要我们的计算机硬盘没有故障，或者我们没有损坏秘密仓库文件）。该标志允许我们向提交添加消息，以便我们记住这个提交的最重要内容（实际上 Git 不允许你在没有消息的情况下提交）。通常的惯例是使用命令形式的动词而不是过去时。例如，上面的提交消息说“add tofu recipes”而不是“added tofu recipes”。</p>
<p>另一个比喻是，你可以将整个过程想象为用相机拍全景照片。命令捕捉图像的一部分，并将所有“添加”的项目拼接成一个全景图，然后将这个全景图扔进保险箱中。正如全景图只包括你指向的内容（而不是围绕你的整个 360 度圈），该命令只包括那些使用命令添加的文件（而不是文件夹中的所有文件）。</p>
<p>提交之后，你会注意到不再列出“Changes to be committed”下的文件。这类似于当你拍完全景照片后，所有临时的小图像文件都会被丢弃。此时的结果如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        seitan/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure>

<p>正如你可能从我们多次使用它中猜到的那样，<code>git status</code> 对于查看仓库中当前发生的事情非常有用。如果你遇到意外行为，这是查看的第一个地方！</p>
<p>如果你查看文件夹中的文件，你会看到提交过程并未影响我们计算机上的原始文件。这很像当你给朋友拍全景照片时，他们并不会被吸进你的手机里的网络地狱。</p>
<p>我们可以使用一个特殊的命令查看快照的证据：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 9f955d85359fc8e4504d7220f13fad34f8f2c62b</span><br><span class="line">Author: Sandra Upson &lt;sandra@Sandras-MacBook-Air.<span class="built_in">local</span>&gt;</span><br><span class="line">Date:   Sun Jan 17 19:06:48 2016 -0800</span><br><span class="line"></span><br><span class="line">    add tofu recipes</span><br></pre></td></tr></table></figure>

<p>那串巨大的字符 <code>9f955d85359fc8e4504d7220f13fad34f8f2c62b</code> 是提交的 ID。我们可以使用<code>git show</code>命令来查看这个提交的内部内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ git show 9f955d85359fc8e4504d7220f13fad34f8f2c62b</span><br><span class="line"></span><br><span class="line">commit 9f955d85359fc8e4504d7220f13fad34f8f2c62b</span><br><span class="line">Author: Sandra Upson &lt;sandra@Sandras-MacBook-Air.<span class="built_in">local</span>&gt;</span><br><span class="line">Date:   Sun Jan 17 19:06:48 2016 -0800</span><br><span class="line"></span><br><span class="line">    add tofu recipes</span><br><span class="line"></span><br><span class="line">diff --git a/tofu/basil_ginger_tofu.txt b/tofu/basil_ginger_tofu.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..9a56e7a</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/tofu/basil_ginger_tofu.txt</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+basil</span><br><span class="line">+ginger</span><br><span class="line">+tofu</span><br><span class="line">diff --git a/tofu/kung_pao_tofu.txt b/tofu/kung_pao_tofu.txt</span><br><span class="line">new file mode 100644 index</span><br><span class="line">0000000..dad9bd9</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/tofu/kung_pao_tofu.txt</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+szechuan peppers</span><br><span class="line">+tofu</span><br><span class="line">+peanuts</span><br><span class="line">+kung</span><br><span class="line">+pao</span><br></pre></td></tr></table></figure>

<p>这些命令和结果展示了如何使用 Git 跟踪和管理文件的版本控制。这些基本操作是 Git 工作流程的核心部分。</p>
<p>如果我们回滚到先前提交的版本，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git restore --<span class="built_in">source</span>=9f955d85359fc8e4504d7220f13fad34f8f2c62b tofu/kung_pao_tofu.txt</span><br></pre></td></tr></table></figure>

<p>使用场景和示例</p>
<ul>
<li>取消工作目录中的修改：</li>
</ul>
<p>如果你对某个文件进行了修改，但想取消这些修改，可以使用 git restore。这会将文件恢复到上一次提交的状态。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore foo.txt <span class="comment">#这将取消对 foo.txt 所做的所有未提交的更改。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>恢复暂存区中的文件：<br>如果你想取消对暂存区中某个文件的修改，但保留工作目录中的修改，可以使用 –staged 选项。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged &lt;filename&gt;</span><br></pre></td></tr></table></figure>
示例：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged foo.txt <span class="comment">#这将把 foo.txt 从暂存区恢复到上一个提交的状态，但保留工作目录中的修改。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从特定提交恢复文件：</li>
</ul>
<p>你还可以从特定的提交恢复文件，而不是当前的最新提交。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --<span class="built_in">source</span> &lt;commit hashcode&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git restore --<span class="built_in">source</span>=9f955d85359fc8e4504d7220f13fad34f8f2c62b tofu/kung_pao_tofu.txt <span class="comment">#这将把 tofu/kung_pao_tofu.txt 恢复到&#x27;9f955d85359fc8e4504d7220f13fad34f8f2c62b&#x27;提交的状态。</span></span><br></pre></td></tr></table></figure>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><pre><code>git init
git status
git  add ./&lt;filename&gt;
git commit
git log
git show &lt;commit hash&gt;
git restore ##不破化提交记录

repo - stages - workpalce
</code></pre>
<ul>
<li>**<code>git init</code>**：创建一个盒子（仓库），永久存储全景照片（提交）。</li>
<li>**<code>git add</code>**：拍摄一个临时照片（暂存），这些照片可以稍后组装成全景照片。</li>
<li>**<code>git commit</code>**：将所有可用的临时照片（暂存的更改）组装成一张全景照片。同时销毁所有临时照片。</li>
<li>**<code>git log</code>**：列出我们拍过的所有全景照片。</li>
<li>**<code>git show</code>**：检查某张特定全景照片的内容。</li>
<li>**<code>git restore</code>**：将文件重新排列成某张全景照片中的样子。这不会影响你盒子中的全景照片。</li>
</ul>
<h3 id="本地仓库技术概览"><a href="#本地仓库技术概览" class="headerlink" title="本地仓库技术概览"></a>本地仓库技术概览</h3><p><img src="/./git.png" alt="git"><br>如图所示，文件分为两大类：</p>
<ol>
<li><p><strong>未跟踪的文件</strong>（untracked files）：这些文件要么从未被跟踪过，要么已从跟踪中移除。Git 不会为这些文件维护历史记录。</p>
</li>
<li><p><strong>已跟踪的文件</strong>（tracked files）：这些文件已添加到 Git 仓库中，可以处于不同的修改状态：未修改、已修改或已暂存。</p>
<p>a. <strong>未修改的文件</strong>（unmodified file）：自从上一个版本被添加到 Git 仓库以来，这个文件没有任何新的更改。</p>
<p>b. <strong>已修改的文件</strong>（modified file）：这个文件与 Git 保存的上一个版本不同。</p>
<p>c. <strong>已暂存的文件</strong>（staged file）：用户指定为未来提交的一部分的文件（通常通过 <code>git add</code> 命令）。我们可以将这些文件视为有灯光照射的文件。</p>
</li>
</ol>
<h4 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h4><p>Git 参考资料中有一个很好的部分关于<a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-revert#Documentation/git-revert.txt-undo">撤销操作</a>。请注意，虽然 Git 是围绕历史记录的概念而构建的，但如果你使用某些撤销命令进行还原，可能会丢失你的工作。因此，在撤销工作之前，请仔细阅读并了解更改的影响。</p>
<ul>
<li><p><strong>将尚未提交的文件取消暂存</strong>：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged [file]</span><br></pre></td></tr></table></figure>

<p>  这会将文件的状态恢复为已修改状态，保留更改。不要担心这个命令会撤销任何工作。这个命令相当于删除你将要组合成全景图的临时图像之一。</p>
<p>  为什么我们需要使用这个命令？假设你不小心开始跟踪了一个你不想跟踪的文件（例如，一个尴尬的自己的视频）。或者你对一个文件进行了修改，原本打算提交但现在不想提交。</p>
</li>
<li><p><strong>修改最新的提交（更改提交信息或添加遗忘的文件）</strong>：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add [forgotten-file]</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>  请注意，这个新的修订提交将替换之前的提交。</p>
</li>
<li><p><strong>恢复文件到最近一次提交时的状态（谨慎使用！）</strong>：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore [file]</span><br></pre></td></tr></table></figure>

<p>  如果文件已经暂存，你需要先取消暂存。</p>
<p>  这个命令在你希望合法地撤销你的工作时非常有用。例如，如果你在之前提交后意外修改了某个文件，并希望将其恢复到之前的状态。</p>
<p>  使用这个命令要小心！自上次提交以来对文件所做的任何更改都将丢失。如果你想安全一些，先暂存并提交你的更改，然后使用以下命令之一将其恢复到之前的版本。</p>
</li>
</ul>
<h4 id="获取文件的先前版本"><a href="#获取文件的先前版本" class="headerlink" title="获取文件的先前版本"></a>获取文件的先前版本</h4><p>假设你正在进行一个实验，做到一半时，你发现自己完全做错了。如果有一种方法可以取回初始代码，这样你就可以重新开始了！</p>
<p>如果你还没有提交，你可以使用前面的命令 —— 但是如果你已经提交了一些更改呢？与其恢复到最新的提交，你可以使用更强大的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --<span class="built_in">source</span>=[commit or branch] [file or folder]</span><br></pre></td></tr></table></figure>

<p>这个命令可以从任意时间点获取文件。例如，假设你意外删除了 <code>lab1000/</code> 并提交了这个更改。哦不！为了修复这个问题，你可以使用以下命令取回初始代码：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --<span class="built_in">source</span>=skeleton/main lab1000/</span><br></pre></td></tr></table></figure>

<p>这允许你从 <code>lab1000/</code> 的初始代码重新开始。</p>
<p>现在考虑一个情景，你在 <code>lab1000/Cheese.txt</code> 上做了一些进展，并希望取回几次提交前的版本。你可以找到包含我们想要恢复版本的正确提交 ID，然后运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> lab1000/Cheese.txt</span><br></pre></td></tr></table></figure>

<p>找出正确的提交 ID 后，运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --<span class="built_in">source</span>=abcd1234efgh7890abcd1234c7ee5e7890c7ee5e lab1000/Cheese.txt</span><br></pre></td></tr></table></figure>

<p>其中 <code>abcd1234efgh7890abcd1234c7ee5e7890c7ee5e</code> 是包含我们想要恢复版本的提交 ID。</p>
<p>记住，你需要重新暂存文件，以便在下次提交时跟踪你的恢复操作！</p>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li>**<code>git clone [remote-repo-URL]</code>**：在本地计算机上创建指定仓库的副本。还会创建一个工作目录，该目录中的文件排列方式与下载仓库中的最新快照完全相同。同时记录远程仓库的 URL，以便后续的网络数据传输，并给它一个特殊的远程仓库名称 **<code>origin</code>**。</li>
<li>**<code>git remote add [remote-repo-name] [remote-repo-URL]</code>**：记录网络数据传输的新位置。</li>
<li>**<code>git remote -v</code>**：列出所有网络数据传输的位置。</li>
<li>**<code>git pull [remote-repo-name] main</code>**：获取文件的最新副本，如 .remote-repo-name 中所示。</li>
<li>**<code>git push [remote-repo-name] main</code>**：将文件的最新副本上传到 .remote-repo-name。</li>
</ul>
<h3 id="Git分支（高级Git）"><a href="#Git分支（高级Git）" class="headerlink" title="Git分支（高级Git）"></a>Git分支（高级Git）</h3><p><strong>注意</strong>：在 2020 年，Git 将默认分支名称从 <code>master</code> 更改为 <code>main</code>。下面的图示尚未相应更新 —— 目前，只需将 <code>master</code> 视为 <code>main</code> 的旧版等价物。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master  main</span><br></pre></td></tr></table></figure>

<p><img src="/./branch1.png" alt="Git Branch Illustration"></p>
<p>到目前为止，我们所覆盖的每个命令都在默认分支上工作。这个分支通常被称为 <code>main</code> 分支。然而，有时候你可能需要在代码中创建分支。</p>
<p>分支允许你同时跟踪工作中的多个不同版本。你可以将分支视为平行的维度。也许一个分支是选择使用链表的结果，而另一个分支是选择使用数组的结果。</p>
<p><img src="/./branch2.png" alt="Git Branch Illustration"></p>
<h3 id="分支的原因"><a href="#分支的原因" class="headerlink" title="分支的原因"></a>分支的原因</h3><p>以下是一些可能需要创建分支的情况：</p>
<ul>
<li>你可能想对现有代码进行重大更改（称为重构），但这会破坏项目的其他部分。然而，你希望能够同时处理其他部分，或者你有合作伙伴，并且你不想破坏他们的代码。</li>
<li>你想开始处理项目的新部分，但你不确定这些更改是否可行，并最终成为成品的一部分。</li>
<li>你与合作伙伴一起工作，并且不想将当前的工作与他们的混在一起，即使你希望将来能够把所有的工作结合在一起。</li>
</ul>
<p>创建分支可以让你同时跟踪工作中的多个不同版本，并且可以轻松地在版本之间切换和合并分支。一旦你完成了某个部分的工作，并希望将其合并到主代码中，你就可以进行合并操作。</p>
<h3 id="一个示例场景"><a href="#一个示例场景" class="headerlink" title="一个示例场景"></a>一个示例场景</h3><p>例如，假设你已经完成了一个项目的一半。还有一个困难的部分需要完成，你不确定如何完成。也许你有三种不同的想法，但你不确定哪一种会奏效。在这种情况下，创建一个分支来尝试第一个想法可能是个好主意。</p>
<ul>
<li>如果你的代码有效，你可以将分支合并回主代码（在 <code>main</code> 分支上）并提交你的项目。</li>
<li>如果你的代码无效，不用担心撤销代码和修改 Git 历史。你可以简单地切换回 <code>main</code> 分支，该分支不会包含任何更改，然后创建另一个分支并尝试第二个想法。</li>
</ul>
<p>你可以这样持续操作，直到找到最佳的代码编写方式，然后只需在最后将工作有效的分支合并回主分支。</p>
<p>Git 参考资料中有一个关于<a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging">分支和合并</a>的部分，其中有关于分支如何在 Git 的底层数据结构中表示的一些图示。实际上，Git 将提交历史作为图表来跟踪，其中包含分支指针和作为图表节点的提交（因此有了与树相关的术语）。</p>
<h3 id="创建、删除和切换分支"><a href="#创建、删除和切换分支" class="headerlink" title="创建、删除和切换分支"></a>创建、删除和切换分支</h3><p>一个特殊的分支指针称为 <code>HEAD</code>，它引用当前作为工作目录的分支。分支指令会修改分支并更改 <code>HEAD</code> 指向的内容，以便你看到文件的不同版本。</p>
<ul>
<li><p>以下命令将基于当前分支创建一个新分支：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch [new-branch-name]</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个命令允许你在分支之间切换，改变 <code>HEAD</code> 指向的分支：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout [branch-name]</span><br></pre></td></tr></table></figure>

<p>  示例：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>创建分支让你可以同时处理代码的不同版本，并且可以在完成部分工作后轻松地合并分支，从而保持代码的整洁和有序。</p>
<h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>有时候你可能想将一个分支合并到另一个分支。例如，假设你对 <code>fixing-ai-heuristics</code> 分支上的工作非常满意。你的 AI 现在非常棒，你希望你的主分支能够看到你在 <code>fixing-ai-heuristics</code> 分支上所做的提交，并删除 <code>fixing-ai-heuristics</code> 分支。<br><img src="/./merge.png" alt="merge"></p>
<p>在这种情况下，你应该切换到 <code>main</code> 分支，并将 <code>fixing-ai-heuristics</code> 分支合并到 <code>main</code> 分支：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git switch main</span><br><span class="line">$ git merge fixing-ai-heuristics</span><br></pre></td></tr></table></figure>

<p>这个命令将创建一个新的提交，将两个分支合并在一起，并更改每个分支的指针以引用这个新的提交。虽然大多数提交只有一个父提交，但这个新的合并提交有两个父提交。<code>main</code> 分支上的提交被称为它的第一个父提交，而 <code>fixing-ai-heuristics</code> 分支上的提交被称为它的第二个父提交。<br><img src="/./merge1.png" alt="merge"></p>
<h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>当你尝试合并两个分支时，可能会发生信息冲突。这种情况可能发生在两个分支的提交更改了相同的文件。Git 足够智能，可以解决许多更改，即使它们发生在同一个文件中的不同地方。</p>
<p>然而，有时候冲突无法通过 Git 解决，因为更改影响了代码中的相同方法或行。在这种情况下，它会将不同分支中的更改呈现给你，作为合并冲突。</p>
<h3 id="合并的示例图示"><a href="#合并的示例图示" class="headerlink" title="合并的示例图示"></a>合并的示例图示</h3><p>上图显示了从 <code>fixing-ai-heuristics</code> 分支合并到 <code>main</code> 分支的示例。在合并之后，新的合并提交（C6）会有两个父提交（C5 和 <code>fixing-ai-heuristics</code> 分支上的最新提交）。</p>
<p>合并之后，你可以继续在 <code>main</code> 分支上进行开发，而 <code>fixing-ai-heuristics</code> 分支上的更改已经被合并到主代码库中。如果发生合并冲突，你需要手动解决这些冲突，然后提交合并结果。</p>
<h3 id="G-远程仓库（高级）"><a href="#G-远程仓库（高级）" class="headerlink" title="G. 远程仓库（高级）"></a>G. 远程仓库（高级）</h3><h4 id="私有仓库-vs-公共仓库"><a href="#私有仓库-vs-公共仓库" class="headerlink" title="私有仓库 vs 公共仓库"></a>私有仓库 vs 公共仓库</h4><p>默认情况下，GitHub 上的仓库是公共的，而不是私有的。这意味着在公共仓库中，互联网上的任何人都可以查看代码。对于所有课程作业，要求使用私有仓库。</p>
<p>从 2019 年 1 月 7 日起，GitHub 提供免费无限制的私有仓库，因此没有理由将代码发布在公共仓库中。</p>
<h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>添加远程仓库意味着你告诉 Git 仓库的位置。你不一定对每个添加的仓库都有读&#x2F;写访问权限。实际上访问和修改远程仓库中的文件将在稍后讨论，并依赖于已添加的远程仓库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [short-name] [remote-url]</span><br></pre></td></tr></table></figure>

<p>远程 URL 看起来像这样，如果你使用 HTTP 或 SSH：</p>
<ul>
<li><code>https://github.com/berkeley-cs61b/skeleton.git</code></li>
<li><code>git@github.com:berkeley-cs61b/skeleton.git</code></li>
</ul>
<p>按照惯例，主远程仓库的名称被称为 <code>origin</code>（原始远程仓库）。因此，以下两个命令中的任意一个都可以让我将仓库添加为远程仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/berkeley-cs61b/skeleton.git</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:berkeley-cs61b/skeleton.git</span><br></pre></td></tr></table></figure>

<p>添加远程仓库后，所有其他命令都使用其关联的简称。</p>
<h4 id="重命名、删除和列出远程仓库"><a href="#重命名、删除和列出远程仓库" class="headerlink" title="重命名、删除和列出远程仓库"></a>重命名、删除和列出远程仓库</h4><ul>
<li><p>你可以使用以下命令重命名远程仓库：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename [old-name] [new-name]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不再使用远程仓库，你也可以将其删除：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">rm</span> [remote-name]</span><br></pre></td></tr></table></figure>
</li>
<li><p>要查看你有哪些远程仓库，你可以列出它们。<code>-v</code> 标志会告诉你每个远程仓库的 URL（不仅仅是它们的名称）。</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li>
</ul>
<p>你可以在 Pro Git 书中阅读更多关于<a target="_blank" rel="noopener" href="https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes">远程仓库工作</a>的信息。</p>
<h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>通常，你会希望将远程仓库中的代码复制到自己的计算机上。在这些情况下，你可以通过克隆远程仓库轻松下载整个仓库及其提交历史：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [remote-url]</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [remote-url] [directory-name]</span><br></pre></td></tr></table></figure>

<p>第一个命令会创建一个与远程仓库同名的目录。第二个命令允许你为复制的仓库指定一个不同的名称。</p>
<p>当你克隆一个远程仓库时，克隆的远程仓库会默认与本地仓库关联，名称为 <code>origin</code>。这是默认的，因为克隆的远程仓库是你本地仓库的初始来源。</p>
<h3 id="推送提交"><a href="#推送提交" class="headerlink" title="推送提交"></a>推送提交</h3><p>你可能希望通过添加一些本地创建的提交来更新远程仓库的内容。你可以通过推送提交来实现这一点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [remote-name] [remote-branch]</span><br></pre></td></tr></table></figure>

<p>请注意，你将从指针当前引用的分支推送到远程分支。例如，假设我克隆了一个仓库并在 <code>main</code> 分支上进行了一些更改。我可以使用以下命令将我的本地更改推送到远程仓库：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure>

<h3 id="获取和拉取提交"><a href="#获取和拉取提交" class="headerlink" title="获取和拉取提交"></a>获取和拉取提交</h3><p>有时候你可能希望从远程仓库获取一些新的提交，而这些提交目前不在你的本地仓库中。例如，你可能克隆了一个由合作伙伴创建的远程仓库，并希望获取他&#x2F;她最新的更改。你可以通过从远程仓库获取或拉取这些更改来实现这一点。</p>
<h4 id="fetch：这相当于下载提交。它不会将它们合并到你的代码中。"><a href="#fetch：这相当于下载提交。它不会将它们合并到你的代码中。" class="headerlink" title="fetch：这相当于下载提交。它不会将它们合并到你的代码中。"></a>fetch：这相当于下载提交。它不会将它们合并到你的代码中。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch [remote-name]</span><br></pre></td></tr></table></figure>

<p>你为什么会使用这个命令？你的合作伙伴可能已经做了一些更改，你希望审查这些更改但将它们与自己的代码分开。获取更改只会更新你本地的远程代码副本，但不会将更改合并到你自己的代码中。</p>
<p>例如，假设你的合作伙伴在远程仓库上创建了一个名为 <code>fixing-ai-heuristics</code> 的新分支。你可以通过以下步骤查看该分支的提交：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git branch review-ai-fix origin/fixing-ai-heuristics</span><br><span class="line">git switch review-ai-fix</span><br></pre></td></tr></table></figure>

<p>第二个命令创建一个名为 <code>review-ai-fix</code> 的新分支，该分支跟踪远程分支 <code>origin/fixing-ai-heuristics</code>。</p>
<h4 id="pull：这相当于-fetch-和-merge-的组合。它不仅会获取最新的更改，还会将这些更改合并到你的分支中。"><a href="#pull：这相当于-fetch-和-merge-的组合。它不仅会获取最新的更改，还会将这些更改合并到你的分支中。" class="headerlink" title="pull：这相当于 fetch 和 merge 的组合。它不仅会获取最新的更改，还会将这些更改合并到你的分支中。"></a>pull：这相当于 <code>fetch</code> 和 <code>merge</code> 的组合。它不仅会获取最新的更改，还会将这些更改合并到你的分支中。</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull [remote-name] [remote-branch-name]</span><br></pre></td></tr></table></figure>

<p>假设我的老板伙伴推送了一些提交到我们的共享远程仓库的分支，这些提交修复了我们的 AI 启发式方法。我知道这些更改不会破坏我的代码，所以我可以立即将其拉取并合并到我的代码中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>

<p>通过使用 <code>pull</code> 命令，我可以获取远程仓库中的最新更改并将其合并到我本地的分支中。</p>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>使用这两个命令设置 Git 将使用的名称和电子邮件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;&lt;你的名字&gt;&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;&lt;你的电子邮件&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>设置 Git 的默认分支名称：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global init.defaultBranch main</span><br></pre></td></tr></table></figure>

<p>设置“合并策略”：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global pull.rebase <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><code>git push</code> 是将本地仓库中的提交推送到远程仓库。具体来说，它将本地仓库的某个分支的提交记录（也就是本地的 commit 历史）推送到远程仓库的对应分支。</p>
<p>以下是更详细的解释：</p>
<h3 id="Git-的三个主要区域"><a href="#Git-的三个主要区域" class="headerlink" title="Git 的三个主要区域"></a>Git 的三个主要区域</h3><ol>
<li><p><strong>工作区（Working Directory）</strong>：</p>
<ul>
<li>这是你实际编辑文件的地方。</li>
</ul>
</li>
<li><p><strong>暂存区（Staging Area）</strong>：</p>
<ul>
<li>当你用 <code>git add</code> 命令将文件添加到暂存区时，这些文件准备好被提交。</li>
</ul>
</li>
<li><p><strong>本地仓库（Local Repository）</strong>：</p>
<ul>
<li>当你用 <code>git commit</code> 命令提交时，暂存区的所有文件被提交到本地仓库，形成一个新的提交（commit）。</li>
</ul>
</li>
</ol>
<h4 id="git-push-的工作原理"><a href="#git-push-的工作原理" class="headerlink" title="git push 的工作原理"></a><code>git push</code> 的工作原理</h4><ul>
<li><strong>本地提交</strong>：<code>git push</code> 是将已经在本地仓库中的提交推送到远程仓库。换句话说，只有已经用 <code>git commit</code> 提交到本地仓库的更改才会被 <code>git push</code> 推送到远程仓库。</li>
<li><strong>推送操作</strong>：<code>git push</code> 不会直接从暂存区推送文件。它推送的是本地仓库中某个分支的提交记录。</li>
</ul>
<h3 id="工作流程示例"><a href="#工作流程示例" class="headerlink" title="工作流程示例"></a>工作流程示例</h3><ol>
<li><p><strong>编辑文件</strong>：在工作区中修改文件。</p>
</li>
<li><p><strong>暂存更改</strong>：使用 <code>git add</code> 命令将修改的文件添加到暂存区。</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提交更改</strong>：使用 <code>git commit</code> 命令将暂存区的文件提交到本地仓库。</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;描述更改内容的提交信息&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>推送到远程仓库</strong>：使用 <code>git push</code> 命令将本地仓库中的提交推送到远程仓库。</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;远程仓库名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<p> 例如，推送到名为 <code>origin</code> 的远程仓库的 <code>main</code> 分支：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li><code>git push</code> 是将本地仓库中的提交记录推送到远程仓库。</li>
<li>只有已经用 <code>git commit</code> 提交到本地仓库的更改才会被 <code>git push</code> 推送到远程仓库。</li>
<li><code>git push</code> 不会直接从暂存区推送文件，而是推送已经在本地仓库中的提交记录。</li>
</ul>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul>
<li>JDK：用于开发 Java 应用程序，包含编译器、运行时环境、类库和开发工具。</li>
<li>JAR：用于分发和部署 Java 应用程序或类库的归档文件格式，可以包含多个 .class 文件和资源文件。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/07/cs61b-lab01/" data-id="clyb7odzb0000iota5alw0fqm" data-title="cs61b-lab01" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2024/07/03/makefile/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Makefile与CMake（于仕琪老师笔记）</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/07/cs61b-lab01/">cs61b-lab01</a>
          </li>
        
          <li>
            <a href="/2024/07/03/makefile/">Makefile与CMake（于仕琪老师笔记）</a>
          </li>
        
          <li>
            <a href="/2024/07/02/GDB/">GDB</a>
          </li>
        
          <li>
            <a href="/2024/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(CS61B)md/">数据结构(CS61B)-图.md</a>
          </li>
        
          <li>
            <a href="/2024/06/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>